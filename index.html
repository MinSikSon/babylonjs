<!DOCTYPE html> <!-- HTML5 문서 선언 -->
<html lang="ko"> <!-- 문서 언어: 한국어 -->
<head>
  <meta charset="UTF-8" /> <!-- UTF-8 인코딩 (한글 깨짐 방지) -->
  <title>Babylon.js Solar System</title> <!-- 브라우저 탭 제목 -->

  <style>
    /* html과 body를 화면 전체로 설정 */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;        /* 기본 여백 제거 */
      overflow: hidden;/* 스크롤바 제거 */
    }

    /* Babylon.js가 그릴 캔버스 */
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none; /* 모바일에서 기본 터치 제스처 비활성화 */
    }
  </style>
</head>

<body>
  <!-- Babylon.js가 3D를 그릴 캔버스 -->
  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js 엔진 로드 (CDN) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
    /* ===============================
       1️⃣ 캔버스 & 엔진 생성
       =============================== */

    // HTML에서 canvas 요소 가져오기
    const canvas = document.getElementById("renderCanvas");

    // Babylon.js 렌더링 엔진 생성
    // 두 번째 인자 true = 안티앨리어싱 활성화
    const engine = new BABYLON.Engine(canvas, true);

    /* ===============================
       2️⃣ Scene 생성 함수
       =============================== */
    var createScene = function () {
      var scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.01, 0.01, 0.02);
  
      // 1. 카메라 설정 (먼 거리까지 볼 수 있도록 maxZ 확장)
      var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3, 800, BABYLON.Vector3.Zero(), scene);
      camera.attachControl(canvas, true);
      camera.maxZ = 100000;
  
      // 2. 조명 및 글로우 효과
      var light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
      light.intensity = 2;
      var gl = new BABYLON.GlowLayer("glow", scene);
      gl.intensity = 0.6;
  
      // 3. 확장된 행성 데이터 (천/해/명 포함)
      const planetsData = [
          { name: "Mercury", dist: 50,  size: 0.5,  rev: 88,    color: new BABYLON.Color3(0.6, 0.6, 0.6) },
          { name: "Venus",   dist: 80,  size: 0.9,  rev: 224,   color: new BABYLON.Color3(0.9, 0.8, 0.2) },
          { name: "Earth",   dist: 120, size: 1.0,  rev: 365,   color: new BABYLON.Color3(0.2, 0.4, 1.0), hasMoon: true },
          { name: "Mars",    dist: 170, size: 0.6,  rev: 687,   color: new BABYLON.Color3(0.9, 0.3, 0.2) },
          { name: "Jupiter", dist: 280, size: 11.2, rev: 4333,  color: new BABYLON.Color3(0.8, 0.7, 0.5), hasRing: true, ringColor: new BABYLON.Color3(0.5, 0.4, 0.3) },
          { name: "Saturn",  dist: 400, size: 9.4,  rev: 10759, color: new BABYLON.Color3(0.9, 0.8, 0.6), hasRing: true, ringColor: new BABYLON.Color3(0.7, 0.6, 0.5) },
          { name: "Uranus",  dist: 520, size: 4.0,  rev: 30687, color: new BABYLON.Color3(0.6, 0.9, 0.9), hasRing: true, ringColor: new BABYLON.Color3(0.4, 0.5, 0.6) },
          { name: "Neptune", dist: 630, size: 3.8,  rev: 60190, color: new BABYLON.Color3(0.3, 0.3, 0.9) },
          { name: "Pluto",   dist: 750, size: 0.3,  rev: 90560, color: new BABYLON.Color3(0.5, 0.4, 0.3), tilt: BABYLON.Tools.ToRadians(17) }
      ];
  
      // 태양 생성
      var sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 30 }, scene);
      var sunMat = new BABYLON.StandardMaterial("sunMat", scene);
      sunMat.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
      sun.material = sunMat;
  
      var planetElements = [];
  
      // 4. 행성/고리/궤적 생성 루프
      planetsData.forEach((data) => {
          var orbitPivot = new BABYLON.TransformNode(data.name + "Pivot");
          if (data.tilt) orbitPivot.rotation.z = data.tilt;
  
          var planet = BABYLON.MeshBuilder.CreateSphere(data.name, { diameter: data.size * 2 }, scene);
          planet.parent = orbitPivot;
          planet.position.x = data.dist;
  
          var mat = new BABYLON.StandardMaterial(data.name + "Mat", scene);
          mat.diffuseColor = data.color;
          planet.material = mat;
  
          // 궤도 라인
          createOrbitCircle(data.dist, scene, orbitPivot);
  
          // 궤적 흔적
          new BABYLON.TrailMesh(data.name + "Trail", planet, scene, 0.3, 300, true);
  
          // 고리 추가 (토성, 목성, 천왕성 등)
          if (data.hasRing) {
              var ring = BABYLON.MeshBuilder.CreateTorus(data.name + "Ring", {
                  diameter: data.size * 4.5,
                  thickness: 0.2,
                  tessellation: 64
              }, scene);
              ring.parent = planet;
              ring.scaling.y = 0.05; // 얇게 만듦
              var ringMat = new BABYLON.StandardMaterial(data.name + "RingMat", scene);
              ringMat.diffuseColor = data.ringColor;
              ringMat.alpha = 0.6;
              ring.material = ringMat;
          }
  
          // 지구의 달
          if (data.hasMoon) {
              var moonPivot = new BABYLON.TransformNode("MoonPivot");
              moonPivot.parent = orbitPivot;
              moonPivot.position.x = data.dist;
              var moon = BABYLON.MeshBuilder.CreateSphere("Moon", { diameter: 0.6 }, scene);
              moon.parent = moonPivot;
              moon.position.x = 4;
              planetElements.push({ pivot: moonPivot, revSpeed: 1 / 27 });
          }
  
          planetElements.push({ pivot: orbitPivot, revSpeed: 1 / data.rev });
      });
  
      // 5. 카이퍼 벨트 (Kuiper Belt) 구현 - 수천 개의 조각들
      const createKuiperBelt = () => {
          const count = 1500;
          const points = [];
          for (let i = 0; i < count; i++) {
              const angle = Math.random() * Math.PI * 2;
              const radius = 800 + Math.random() * 100; // 명왕성 궤도 밖
              const x = Math.cos(angle) * radius;
              const z = Math.sin(angle) * radius;
              const y = (Math.random() - 0.5) * 20; // 약간의 두께감
              points.push(new BABYLON.Vector3(x, y, z));
          }
          
          const pcs = new BABYLON.PointsCloudSystem("pcs", 2, scene);
          pcs.addPoints(count, (particle, i) => {
              particle.position = points[i];
              particle.color = new BABYLON.Color3(0.4, 0.4, 0.45);
          });
          pcs.buildMeshAsync();
      };
      createKuiperBelt();
  
      function createOrbitCircle(radius, scene, parent) {
          const points = [];
          for (let i = 0; i <= 360; i++) {
              const angle = BABYLON.Tools.ToRadians(i);
              points.push(new BABYLON.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
          }
          const lines = BABYLON.MeshBuilder.CreateLines("orbit", { points }, scene);
          lines.color = new BABYLON.Color3(0.1, 0.1, 0.1);
          lines.parent = parent;
      }
  
      // 6. 애니메이션 루프
      // let timeScale = 5.0; // 외행성들이 워낙 느려 속도를 높였습니다.
      let timeScale = 0.2; // 외행성들이 워낙 느려 속도를 높였습니다.
      scene.onBeforeRenderObservable.add(() => {
          const deltaTime = scene.getEngine().getDeltaTime() * 0.1 * timeScale;
          planetElements.forEach(p => {
              p.pivot.rotation.y += p.revSpeed * deltaTime;
          });
      });
  
      return scene;
  };

    /* ===============================
       11️⃣ Scene 생성
       =============================== */

    const scene = createScene();

    /* ===============================
       12️⃣ 렌더 루프
       =============================== */

    // 매 프레임마다 scene을 그림
    engine.runRenderLoop(() => {
      scene.render();
    });

    /* ===============================
       13️⃣ 창 크기 변경 대응
       =============================== */

    window.addEventListener("resize", () => {
      engine.resize(); // 캔버스 크기 재조정
    });
  </script>
</body>
</html>

