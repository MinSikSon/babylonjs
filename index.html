<!DOCTYPE html> <!-- HTML5 문서 선언 -->
<html lang="ko"> <!-- 문서 언어: 한국어 -->
<head>
  <meta charset="UTF-8" /> <!-- UTF-8 인코딩 (한글 깨짐 방지) -->
  <title>Babylon.js Solar System</title> <!-- 브라우저 탭 제목 -->

  <style>
    /* html과 body를 화면 전체로 설정 */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;        /* 기본 여백 제거 */
      overflow: hidden;/* 스크롤바 제거 */
    }

    /* Babylon.js가 그릴 캔버스 */
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none; /* 모바일에서 기본 터치 제스처 비활성화 */
    }
  </style>
</head>

<body>
  <!-- Babylon.js가 3D를 그릴 캔버스 -->
  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js 엔진 로드 (CDN) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
    /* ===============================
       1️⃣ 캔버스 & 엔진 생성
       =============================== */

    // HTML에서 canvas 요소 가져오기
    const canvas = document.getElementById("renderCanvas");

    // Babylon.js 렌더링 엔진 생성
    // 두 번째 인자 true = 안티앨리어싱 활성화
    const engine = new BABYLON.Engine(canvas, true);

    /* ===============================
       2️⃣ Scene 생성 함수
       =============================== */
    // 외부에서 호출 가능하도록 scene 생성 함수를 내보냅니다.
    var createScene = function () {
        // 1. 기초 설정: 렌더링이 일어날 장면(Scene)과 배경색을 정의합니다.
        var scene = new BABYLON.Scene(engine);
        // 우주 느낌을 주기 위해 아주 어두운 남색 배경 설정 (RGB 값: 0.01, 0.01, 0.02)
        scene.clearColor = new BABYLON.Color3(0.01, 0.01, 0.02);
    
        // 2. 카메라 설정: 사용자가 마우스로 중심을 축으로 회전하며 볼 수 있는 카메라
        // 인자: 이름, 좌우회전(alpha), 상하회전(beta), 거리(radius), 타겟, 장면
        var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3, 800, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true); // 마우스/터치 조작 활성화
        // 우주 크기가 크므로 카메라가 볼 수 있는 최대 거리(Far Clip Plane)를 10만 유닛으로 대폭 확장
        camera.maxZ = 100000;
    
        // 3. 조명 및 시각 효과
        // 태양 위치(0,0,0)에서 빛이 퍼져나가는 점광원 생성
        var light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
        light.intensity = 2; // 광도 설정
    
        // 빛나는 효과(Bloom)를 주는 글로우 레이어 추가 (태양과 궤적을 빛나게 함)
        var gl = new BABYLON.GlowLayer("glow", scene);
        gl.intensity = 0.6;
    
        // 4. 행성 데이터 정의: 모든 행성의 속성을 배열로 관리 (유지보수 용이)
        const planetsData = [
            { name: "Mercury", dist: 50,  size: 0.5,  rev: 88,    color: new BABYLON.Color3(0.6, 0.6, 0.6) },
            { name: "Venus",   dist: 80,  size: 0.9,  rev: 224,   color: new BABYLON.Color3(0.9, 0.8, 0.2) },
            { name: "Earth",   dist: 120, size: 1.0,  rev: 365,   color: new BABYLON.Color3(0.2, 0.4, 1.0), hasMoon: true },
            { name: "Mars",    dist: 170, size: 0.6,  rev: 687,   color: new BABYLON.Color3(0.9, 0.3, 0.2) },
            // 거대 가스 행성들 (Ring 속성 포함)
            { name: "Jupiter", dist: 280, size: 11.2, rev: 4333,  color: new BABYLON.Color3(0.8, 0.7, 0.5), hasRing: true, ringColor: new BABYLON.Color3(0.5, 0.4, 0.3) },
            { name: "Saturn",  dist: 400, size: 9.4,  rev: 10759, color: new BABYLON.Color3(0.9, 0.8, 0.6), hasRing: true, ringColor: new BABYLON.Color3(0.7, 0.6, 0.5) },
            { name: "Uranus",  dist: 520, size: 4.0,  rev: 30687, color: new BABYLON.Color3(0.6, 0.9, 0.9), hasRing: true, ringColor: new BABYLON.Color3(0.4, 0.5, 0.6) },
            { name: "Neptune", dist: 630, size: 3.8,  rev: 60190, color: new BABYLON.Color3(0.3, 0.3, 0.9) },
            // 명왕성: 비스듬한 공전 궤도(tilt) 적용
            { name: "Pluto",   dist: 750, size: 0.3,  rev: 90560, color: new BABYLON.Color3(0.5, 0.4, 0.3), tilt: BABYLON.Tools.ToRadians(17) }
        ];
    
        // 5. 태양 객체 생성
        var sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 30 }, scene);
        var sunMat = new BABYLON.StandardMaterial("sunMat", scene);
        // 태양은 스스로 빛나므로 emissiveColor(발광색) 사용
        sunMat.emissiveColor = new BABYLON.Color3(1, 0.4, 0); 
        sun.material = sunMat;
    
        // 애니메이션 업데이트를 위해 행성 피벗들을 담을 배열
        var planetElements = [];
    
        // 6. 행성 생성 루프: 위 배열 데이터를 바탕으로 실제 메쉬 생성
        planetsData.forEach((data) => {
            // [중요] 피벗 노드: 행성 자체가 아닌 이 노드를 회전시켜 공전을 구현함
            var orbitPivot = new BABYLON.TransformNode(data.name + "Pivot");
            // 명왕성 같은 경우 궤도 자체를 기울임
            if (data.tilt) orbitPivot.rotation.z = data.tilt;
    
            // 행성 메쉬 생성 (diameter는 반지름*2)
            var planet = BABYLON.MeshBuilder.CreateSphere(data.name, { diameter: data.size * 2 }, scene);
            planet.parent = orbitPivot; // 피벗의 자식으로 설정
            planet.position.x = data.dist; // 태양으로부터의 거리만큼 이동
    
            // 행성 재질 설정
            var mat = new BABYLON.StandardMaterial(data.name + "Mat", scene);
            mat.diffuseColor = data.color;
            planet.material = mat;
    
            // 보조 시각 효과: 궤도 원선 그리기
            createOrbitCircle(data.dist, scene, orbitPivot);
    
            // 보조 시각 효과: 행성이 지나간 자리에 남는 꼬리(Trail) 생성
            new BABYLON.TrailMesh(data.name + "Trail", planet, scene, 0.3, 300, true);
    
            // 고리가 있는 행성 처리 (토성 등)
            if (data.hasRing) {
                var ring = BABYLON.MeshBuilder.CreateTorus(data.name + "Ring", {
                    diameter: data.size * 4.5,
                    thickness: 0.2,
                    tessellation: 64
                }, scene);
                ring.parent = planet; // 행성을 따라다니도록 설정
                ring.scaling.y = 0.05; // 도넛 형태를 얇게 눌러 고리 모양으로 만듦
                var ringMat = new BABYLON.StandardMaterial(data.name + "RingMat", scene);
                ringMat.diffuseColor = data.ringColor;
                ringMat.alpha = 0.6; // 투명도 부여
                ring.material = ringMat;
            }
    
            // 지구의 달 처리
            if (data.hasMoon) {
                var moonPivot = new BABYLON.TransformNode("MoonPivot");
                moonPivot.parent = orbitPivot; // 지구의 공전 피벗을 따름
                moonPivot.position.x = data.dist; // 지구의 위치에 피벗 배치
                var moon = BABYLON.MeshBuilder.CreateSphere("Moon", { diameter: 0.6 }, scene);
                moon.parent = moonPivot;
                moon.position.x = 4; // 지구로부터의 거리
                // 달의 공전 속도 정보 저장
                planetElements.push({ pivot: moonPivot, revSpeed: 1 / 27 });
            }
    
            // 행성의 공전 속도 정보 저장 (1/공전주기)
            planetElements.push({ pivot: orbitPivot, revSpeed: 1 / data.rev });
        });
    
        // 7. 카이퍼 벨트 (태양계 외곽 소행성 지대)
        const createKuiperBelt = () => {
            // 1. 입자 개수 조절 (가시성을 위해 600~800개가 적당함)
            const count = 700; 
            const sps = new BABYLON.SolidParticleSystem("sps", scene);
            
            // 2. 입자 모양을 약간 더 크게 (size를 0.5에서 1.2로 상향)
            const asteroidBox = BABYLON.MeshBuilder.CreateBox("b", { size: 1.2 }, scene);
            sps.addShape(asteroidBox, count);
            asteroidBox.dispose(); 
    
            sps.initParticles = () => {
                for (let p = 0; p < sps.nbParticles; p++) {
                    const particle = sps.particles[p];
                    const angle = Math.random() * Math.PI * 2;
                    // 분포 범위를 약간 더 넓혀 웅장하게 표현
                    const radius = 900 + Math.random() * 250; 
                    
                    particle.position.x = Math.cos(angle) * radius;
                    particle.position.z = Math.sin(angle) * radius;
                    // 두께감을 주어 띠(Belt) 형태 강조
                    particle.position.y = (Math.random() - 0.5) * 40; 
                    
                    // 크기 변화폭을 키워 불규칙한 느낌 강조
                    const s = Math.random() * 1.5 + 0.5;
                    particle.scaling = new BABYLON.Vector3(s, s, s);
                    
                    // [색상 변경] 더 밝고 선명한 네온 퍼플 & 사이안 블루
                    // 시인성을 위해 채도와 명도를 대폭 높였습니다.
                    particle.color = new BABYLON.Color4(
                        0.6 + Math.random() * 0.4, // Red (보라색 기운)
                        0.3 + Math.random() * 0.3, // Green
                        0.9 + Math.random() * 0.1, // Blue (강한 푸른색)
                        1.0
                    );
                }
            };
    
            const mesh = sps.buildMesh();
            sps.initParticles();
            sps.setParticles(); 
    
            // 3. 재질 설정 - 가시성의 핵심
            const mat = new BABYLON.StandardMaterial("kMat", scene);
            mat.disableLighting = true; // 외부 조명 무시 (어두워지는 것 방지)
            
            // 발광색을 밝은 보라색으로 설정하여 화면에서 "툭" 튀어나오게 함
            mat.emissiveColor = new BABYLON.Color3(0.5, 0.2, 0.8); 
            
            // 만약 GlowLayer가 있다면 이 메쉬는 아주 예쁘게 빛날 것입니다.
            mesh.material = mat;
            
            // 성능 최적화
            mesh.freezeWorldMatrix();
        };
        createKuiperBelt();
    
        // 8. 궤도 가이드 라인 생성 함수
        function createOrbitCircle(radius, scene, parent) {
            const points = [];
            for (let i = 0; i <= 360; i++) {
                const angle = BABYLON.Tools.ToRadians(i);
                points.push(new BABYLON.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
            }
            // 선(Line)을 생성하여 부모 피벗에 붙임
            const lines = BABYLON.MeshBuilder.CreateLines("orbit", { points }, scene);
            lines.color = new BABYLON.Color3(0.1, 0.1, 0.1); // 아주 연한 회색
            lines.parent = parent;
        }
    
        // 9. 실시간 애니메이션 연산
        // timeScale: 공전 속도를 일괄적으로 조절하는 배율
        let timeScale = 0.2; 
        scene.onBeforeRenderObservable.add(() => {
            // 프레임 간 경과 시간(deltaTime)에 속도 상수를 곱함
            const deltaTime = scene.getEngine().getDeltaTime() * 0.1 * timeScale;
            planetElements.forEach(p => {
                // 각 피벗 노드를 Y축(수직축) 기준으로 회전시켜 공전 구현
                p.pivot.rotation.y += p.revSpeed * deltaTime;
            });
        });
    
        return scene; // 완성된 장면 반환
    };

    /* ===============================
       11️⃣ Scene 생성
       =============================== */

    const scene = createScene();

    /* ===============================
       12️⃣ 렌더 루프
       =============================== */

    // 매 프레임마다 scene을 그림
    engine.runRenderLoop(() => {
      scene.render();
    });

    /* ===============================
       13️⃣ 창 크기 변경 대응
       =============================== */

    window.addEventListener("resize", () => {
      engine.resize(); // 캔버스 크기 재조정
    });
  </script>
</body>
</html>

