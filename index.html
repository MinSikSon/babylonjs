<!DOCTYPE html> <!-- HTML5 문서 선언 -->
<html lang="ko"> <!-- 문서 언어: 한국어 -->
<head>
  <meta charset="UTF-8" /> <!-- UTF-8 인코딩 (한글 깨짐 방지) -->
  <title>Babylon.js Solar System</title> <!-- 브라우저 탭 제목 -->

  <style>
    /* html과 body를 화면 전체로 설정 */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;        /* 기본 여백 제거 */
      overflow: hidden;/* 스크롤바 제거 */
    }

    /* Babylon.js가 그릴 캔버스 */
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none; /* 모바일에서 기본 터치 제스처 비활성화 */
    }
  </style>
</head>

<body>
  <!-- Babylon.js가 3D를 그릴 캔버스 -->
  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js 엔진 로드 (CDN) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
    /* ===============================
       1️⃣ 캔버스 & 엔진 생성
       =============================== */

    // HTML에서 canvas 요소 가져오기
    const canvas = document.getElementById("renderCanvas");

    // Babylon.js 렌더링 엔진 생성
    // 두 번째 인자 true = 안티앨리어싱 활성화
    const engine = new BABYLON.Engine(canvas, true);

    /* ===============================
       2️⃣ Scene 생성 함수
       =============================== */
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        
        // 환경 설정
        engine.setHardwareScalingLevel(1); 
        scene.clearColor = new BABYLON.Color4(0, 0, 0.005, 1);
    
        var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/2.5, 1200, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.maxZ = 300000;
    
        var light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
        light.intensity = 3.5;
    
        // 행성 데이터
        const planetsData = [
            { name: "Mercury", dist: 70, size: 1.2, rev: 88, color: new BABYLON.Color3(0.6, 0.6, 0.6) },
            { name: "Venus", dist: 120, size: 2.2, rev: 224, color: new BABYLON.Color3(0.9, 0.8, 0.4) },
            { name: "Earth", dist: 180, size: 2.5, rev: 365, color: new BABYLON.Color3(0.2, 0.5, 1.0), hasMoon: true },
            { name: "Mars", dist: 250, size: 1.5, rev: 687, color: new BABYLON.Color3(0.9, 0.4, 0.3) },
            { name: "Jupiter", dist: 400, size: 14.0, rev: 4333, color: new BABYLON.Color3(0.8, 0.7, 0.5), hasRing: true },
            { name: "Saturn", dist: 580, size: 12.0, rev: 10759, color: new BABYLON.Color3(0.9, 0.8, 0.6), hasRing: true },
            { name: "Uranus", dist: 750, size: 6.0, rev: 30687, color: new BABYLON.Color3(0.6, 0.9, 0.9), hasRing: true, isTilt: true },
            { name: "Neptune", dist: 900, size: 5.8, rev: 60190, color: new BABYLON.Color3(0.3, 0.3, 0.9) },
            { name: "Pluto", dist: 1100, size: 0.6, rev: 90560, color: new BABYLON.Color3(0.5, 0.4, 0.3), tilt: 0.3 }
        ];
    
        // 태양
        var sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 50 }, scene);
        var sunMat = new BABYLON.StandardMaterial("sunMat", scene);
        sunMat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.1);
        sunMat.disableLighting = true;
        sun.material = sunMat;
    
        var animationElements = [];
    
        planetsData.forEach((data) => {
            var planetPivot = new BABYLON.TransformNode(data.name + "Pivot");
            if (data.tilt) planetPivot.rotation.z = data.tilt;
    
            var planet = BABYLON.MeshBuilder.CreateSphere(data.name, { diameter: data.size * 2 }, scene);
            planet.parent = planetPivot;
            planet.position.x = data.dist;
    
            var mat = new BABYLON.StandardMaterial(data.name + "Mat", scene);
            mat.diffuseColor = data.color;
            mat.specularColor = new BABYLON.Color3(0,0,0);
            planet.material = mat;
    
            createOrbitCircle(data.dist, scene, planetPivot);
    
            // 궤도 흔적 (Trail) - 안전한 재질 할당 방식
            var trail = new BABYLON.TrailMesh(data.name + "Trail", planet, scene, 0.4, 300, true);
            var trailMat = new BABYLON.StandardMaterial(data.name + "TrailMat", scene);
            trailMat.emissiveColor = data.color.scale(0.5);
            trailMat.alpha = 0.5;
            trail.material = trailMat;
    
            if (data.hasRing) {
                var ring = BABYLON.MeshBuilder.CreateTorus(data.name + "Ring", { diameter: data.size * 5, thickness: data.size * 0.4, tessellation: 48 }, scene);
                ring.parent = planet;
                ring.scaling.y = 0.05;
                if (data.isTilt) ring.rotation.z = Math.PI/2;
                var rMat = new BABYLON.StandardMaterial("rMat", scene);
                rMat.diffuseColor = data.color;
                rMat.alpha = 0.4;
                rMat.backFaceCulling = false;
                ring.material = rMat;
            }
    
            if (data.hasMoon) {
                var mPivot = new BABYLON.TransformNode("mPivot");
                mPivot.parent = planetPivot;
                mPivot.position.x = data.dist;
                var moon = BABYLON.MeshBuilder.CreateSphere("Moon", { diameter: 0.8 }, scene);
                moon.parent = mPivot;
                moon.position.x = 8;
                animationElements.push({ pivot: mPivot, speed: 1/27 });
            }
    
            animationElements.push({ pivot: planetPivot, speed: 1 / data.rev });
        });
    
        // ------------------------------------------------------------
        // [핵심 업데이트] 훨씬 풍성한 카이퍼 벨트 구현
        // ------------------------------------------------------------
        const kuiperBeltPivot = new BABYLON.TransformNode("kuiperPivot");
        const particleCount = 1200; // 개수를 대폭 늘림
        
        for (let i = 0; i < particleCount; i++) {
            // 소행성마다 다른 크기와 모양(Box/Polyhedron 등 대신 간단한 Box 사용)
            const size = Math.random() * 1.5 + 0.5;
            const asteroid = BABYLON.MeshBuilder.CreateBox("asteroid", {size: size}, scene);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 1200 + Math.random() * 300; // 해왕성/명왕성 너머 더 넓은 대역
            
            // 도넛 모양의 벨트를 위해 Y축(두께) 분산
            asteroid.position = new BABYLON.Vector3(
                Math.cos(angle) * radius, 
                (Math.random() - 0.5) * 50, // 벨트의 두께감
                Math.sin(angle) * radius
            );
            
            // 무작위 회전값으로 자연스러움 추가
            asteroid.rotation = new BABYLON.Vector3(Math.random(), Math.random(), Math.random());
            asteroid.parent = kuiperBeltPivot;
    
            var kMat = new BABYLON.StandardMaterial("kMat", scene);
            // 차가운 외곽 느낌의 색상 (청백색/회색 혼합)
            const colorVal = 0.4 + Math.random() * 0.4;
            kMat.diffuseColor = new BABYLON.Color3(colorVal, colorVal, colorVal + 0.2);
            // 스스로 은은하게 빛나도록 설정 (가시성 확보)
            kMat.emissiveColor = new BABYLON.Color3(0.15, 0.15, 0.25);
            
            asteroid.material = kMat;
            asteroid.freezeWorldMatrix(); // 성능 최적화 (이동하지 않는 객체)
        }
    
        function createOrbitCircle(radius, scene, parent) {
            const points = [];
            for (let i = 0; i <= 360; i+=3) {
                const a = BABYLON.Tools.ToRadians(i);
                points.push(new BABYLON.Vector3(Math.cos(a) * radius, 0, Math.sin(a) * radius));
            }
            const lines = BABYLON.MeshBuilder.CreateLines("orb", { points }, scene);
            lines.color = new BABYLON.Color3(0.1, 0.1, 0.2);
            lines.parent = parent;
        }
    
        let timeScale = 0.2; 
        scene.onBeforeRenderObservable.add(() => {
            const delta = scene.getEngine().getDeltaTime() * 0.1 * timeScale;
            animationElements.forEach(el => {
                el.pivot.rotation.y += el.speed * delta;
            });
            // 카이퍼 벨트 전체도 아주 미세하게 회전시켜 생동감 부여
            kuiperBeltPivot.rotation.y += 0.00003 * delta;
        });
    
        return scene;
    };

    /* ===============================
       11️⃣ Scene 생성
       =============================== */

    const scene = createScene();

    /* ===============================
       12️⃣ 렌더 루프
       =============================== */

    // 매 프레임마다 scene을 그림
    engine.runRenderLoop(() => {
      scene.render();
    });

    /* ===============================
       13️⃣ 창 크기 변경 대응
       =============================== */

    window.addEventListener("resize", () => {
      engine.resize(); // 캔버스 크기 재조정
    });
  </script>
</body>
</html>

