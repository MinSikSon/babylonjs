<!DOCTYPE html> <!-- HTML5 문서 선언 -->
<html lang="ko"> <!-- 문서 언어: 한국어 -->
<head>
  <meta charset="UTF-8" /> <!-- UTF-8 인코딩 (한글 깨짐 방지) -->
  <title>Babylon.js Solar System</title> <!-- 브라우저 탭 제목 -->

  <style>
    /* html과 body를 화면 전체로 설정 */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;        /* 기본 여백 제거 */
      overflow: hidden;/* 스크롤바 제거 */
    }

    /* Babylon.js가 그릴 캔버스 */
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none; /* 모바일에서 기본 터치 제스처 비활성화 */
    }
  </style>
</head>

<body>
  <!-- Babylon.js가 3D를 그릴 캔버스 -->
  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js 엔진 로드 (CDN) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
    /* ===============================
       1️⃣ 캔버스 & 엔진 생성
       =============================== */

    // HTML에서 canvas 요소 가져오기
    const canvas = document.getElementById("renderCanvas");

    // Babylon.js 렌더링 엔진 생성
    // 두 번째 인자 true = 안티앨리어싱 활성화
    const engine = new BABYLON.Engine(canvas, true);

    /* ===============================
       2️⃣ Scene 생성 함수
       =============================== */
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);
    
        // 1. 카메라 설정
        var camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 3, 500, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.maxZ = 50000;
        camera.minZ = 0.1; // TrailMesh가 잘 보이도록 최소 Z값 설정
    
        // 2. 조명 및 효과
        var basicLight = new BABYLON.HemisphericLight("baseLight",
         BABYLON.Vector3(0,0,0),
         scene);
        var light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
        light.intensity = 2;
        var gl = new BABYLON.GlowLayer("glow", scene);
        gl.intensity = 0.5;
    
        // 3. 실제 기반 데이터 (단위: 상대값)
        const realData = [
            { name: "Mercury", dist: 40, size: 0.4, rev: 88, rot: 58.6, color: new BABYLON.Color3(0.6, 0.6, 0.6) },
            { name: "Venus",   dist: 70, size: 0.9, rev: 224, rot: -243, color: new BABYLON.Color3(0.9, 0.8, 0.2) },
            { name: "Earth",   dist: 100, size: 1.0, rev: 365, rot: 1, color: new BABYLON.Color3(0.2, 0.4, 0.9), hasMoon: true }, // 달 추가 플래그
            { name: "Mars",    dist: 150, size: 0.5, rev: 687, rot: 1.03, color: new BABYLON.Color3(0.9, 0.4, 0.3) },
            { name: "Jupiter", dist: 250, size: 11.2, rev: 4333, rot: 0.41, color: new BABYLON.Color3(0.8, 0.7, 0.5) },
            { name: "Saturn",  dist: 350, size: 9.4, rev: 10759, rot: 0.45, color: new BABYLON.Color3(0.7, 0.6, 0.3) }
        ];
    
        // 태양
        var sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 25 }, scene);
        var sunMat = new BABYLON.StandardMaterial("sunMat", scene);
        sunMat.emissiveColor = new BABYLON.Color3(1, 0.3, 0);
        sun.material = sunMat;
    
        var planetMeshes = [];
    
        // 4. 행성 및 달 생성 루프
        realData.forEach((data) => {
            var orbitPivot = new BABYLON.TransformNode(data.name + "Pivot"); // 공전 피벗
    
            var planet = BABYLON.MeshBuilder.CreateSphere(data.name, { diameter: data.size * 2 }, scene);
            planet.parent = orbitPivot;
            planet.position.x = data.dist;
    
            var mat = new BABYLON.StandardMaterial(data.name + "Mat", scene);
            mat.diffuseColor = data.color;
            planet.material = mat;
    
            // 궤도 라인
            createOrbitCircle(data.dist, scene);
    
            // 궤적 흔적 (TrailMesh)
            new BABYLON.TrailMesh(data.name + "Trail", planet, scene, 0.5, 160, true); // diameter: 0.5, capacity: 60 (점의 개수)
    
            // 달 추가 (hasMoon 플래그가 true인 경우)
            if (data.hasMoon) {
                // 달의 공전 피벗 (지구 공전 피벗에 종속)
                var moonOrbitPivot = new BABYLON.TransformNode("MoonOrbitPivot", scene);
                moonOrbitPivot.parent = orbitPivot; // 지구의 공전 피벗을 부모로 설정
                moonOrbitPivot.position = planet.position.clone(); // 지구 위치로 이동 (공전 중심)
    
                // 달 메쉬
                var moon = BABYLON.MeshBuilder.CreateSphere("Moon", { diameter: 0.5 }, scene); // 달 크기 조정
                moon.parent = moonOrbitPivot;
                moon.position.x = 5; // 지구로부터의 거리 (조정 가능)
    
                var moonMat = new BABYLON.StandardMaterial("moonMat", scene);
                moonMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                moon.material = moonMat;
    
                // 달의 공전 궤도 라인 (지구 주변)
                createOrbitCircle(5, scene, moonOrbitPivot);
    
                // 달의 궤적 흔적
                new BABYLON.TrailMesh("MoonTrail", moon, scene, 0.2, 130, true); // 궤적 굵기, 길이
    
                // 달 애니메이션 정보 추가
                planetMeshes.push({
                    mesh: moon,
                    pivot: moonOrbitPivot, // 달은 지구 공전 피벗 기준
                    revSpeed: 1 / 27.3, // 달의 공전 주기 (약 27.3일)
                    rotSpeed: 1 / 27.3 // 달의 자전 주기 (동주기 자전)
                });
            }
    
            planetMeshes.push({
                mesh: planet,
                pivot: orbitPivot,
                revSpeed: 1 / data.rev,
                rotSpeed: 1 / data.rot
            });
        });
    
        // 5. 공전 궤도 원형 라인 함수
        function createOrbitCircle(radius, scene, parent = null) {
            const points = [];
            for (let i = 0; i <= 200; i++) {
                const angle = (i / 200) * 2 * Math.PI;
                points.push(new BABYLON.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
            }
            const lines = BABYLON.MeshBuilder.CreateLines("orbitCircle", { points: points }, scene);
            lines.color = new BABYLON.Color3(0.15, 0.15, 0.15);
            if (parent) {
                lines.parent = parent; // 부모 TransformNode에 종속
            }
        }
    
        // 6. 애니메이션 루프 (속도 조절)
        let timeScale = 0.5; // 시뮬레이션 속도 조절
    
        scene.onBeforeRenderObservable.add(() => {
            const deltaTime = scene.getEngine().getDeltaTime() * 0.01 * timeScale;
    
            planetMeshes.forEach((p) => {
                if (p.pivot) { // 피벗이 있는 경우 공전
                    p.pivot.rotation.y += p.revSpeed * deltaTime;
                }
                if (p.mesh) { // 메쉬가 있는 경우 자전
                    p.mesh.rotation.y += p.rotSpeed * deltaTime;
                }
            });
        });
    
        return scene;
    };

    /* ===============================
       11️⃣ Scene 생성
       =============================== */

    const scene = createScene();

    /* ===============================
       12️⃣ 렌더 루프
       =============================== */

    // 매 프레임마다 scene을 그림
    engine.runRenderLoop(() => {
      scene.render();
    });

    /* ===============================
       13️⃣ 창 크기 변경 대응
       =============================== */

    window.addEventListener("resize", () => {
      engine.resize(); // 캔버스 크기 재조정
    });
  </script>
</body>
</html>

